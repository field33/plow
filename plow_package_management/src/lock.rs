#![allow(clippy::use_self)]

use crate::package::OrganizationToResolveFor;
use anyhow::bail;
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

use crate::{
    package::{PackageSet, PackageVersion, PackageVersionWithRegistryMetadata},
    registry::Registry,
    resolve::Resolver,
};

/// Common name between all lock files for ontologies.
pub const LOCK_FILE_NAME: &str = "Ontology.lock";

/// A runtime representation of a lock file.
#[derive(Debug, Clone)]
pub struct LockFile {
    // Maybe necessary later.
    _path: Option<PathBuf>,
    pub locked_dependencies: PackageSet,
}

impl LockFile {
    /// Writes the conceptual lock file to the given path.
    ///
    /// This mimics Cargo.lock and produces a similar structure, like below.
    ///
    /// ```toml
    /// [[package]]
    /// name = "@namespace/name"
    /// # A complete bare version.
    /// version = "0.2.15"
    /// # Currently left empty
    /// source = ""
    /// checksum = "24606928a235e73cdef55a0c909719cadd72fce573e5713d58cb2952d8f5794c"
    /// # Set of dependencies with corresponding versions.
    /// dependencies = [
    ///  "@x/y 0.24.0",
    ///  "@a/b 1.15.0",
    /// ]
    /// ```
    fn write<T: AsRef<Path>>(
        selected_file: Option<T>,
        package_set: &[PackageVersionWithRegistryMetadata],
    ) -> Result<PathBuf, anyhow::Error> {
        let packages = PackagesInLockFile {
            version: FileVersion::V1,
            packages: package_set.iter().cloned().map_into().collect(),
        };

        let serialized = toml::to_string_pretty(&packages)?;

        if let Some(selected_file) = selected_file {
            if let Some(package_dir) = selected_file.as_ref().parent() {
                let lock_file_path = package_dir.join(LOCK_FILE_NAME);
                let mut lock_file_contents = "# This file is automatically generated by Field33.\n# It is not intended for manual editing.\n\n".to_owned();
                lock_file_contents += &serialized;
                std::fs::write(&lock_file_path, lock_file_contents)?;

                return Ok(lock_file_path);
            }
            bail!("Couldn't determine the directory to write the lock file.");
        }
        bail!("Couldn't determine the directory to write the lock file.");
    }

    pub fn deserialize_lock_file<T: AsRef<Path>>(
        lock_file_path: T,
    ) -> Result<PackagesInLockFile, anyhow::Error> {
        let lock_file_contents = std::fs::read_to_string(lock_file_path)?;
        Ok(toml::from_str::<PackagesInLockFile>(&lock_file_contents)?)
    }

    pub fn previous_lock_file_exists(selected_file: Option<PathBuf>) -> Option<PathBuf> {
        selected_file.and_then(|selected_file| {
            selected_file.parent().and_then(|package_dir| {
                let lock_file_path_in_package_dir = package_dir.join(LOCK_FILE_NAME);
                if lock_file_path_in_package_dir.exists() {
                    return Some(lock_file_path_in_package_dir);
                }
                None
            })
        })
    }

    /// Starts locking operation, resolves dependencies and write the lock file.
    pub fn lock_with_registry(
        package_to_resolve: OrganizationToResolveFor,
        registry: &dyn Registry,
        selected_file: Option<PathBuf>,
    ) -> Result<Self, anyhow::Error> {
        // TODO: Either this or another entry point will be expanded to support db based locks in the future.

        let (resolved_dependencies, previously_locked_path) =
            if let Some(lock_file_path) = Self::previous_lock_file_exists(selected_file.clone()) {
                // With existing lock file input
                let packages = Self::deserialize_lock_file(&lock_file_path)?.packages;
                (
                    Into::<crate::resolve::VersionRequestResolver>::into(registry)
                        .resolve_dependencies(package_to_resolve, Some(&packages))?,
                    Some(lock_file_path),
                )
            } else {
                // No lockfile input
                (
                    Into::<crate::resolve::VersionRequestResolver>::into(registry)
                        .resolve_dependencies(package_to_resolve, None)?,
                    None,
                )
            };

        let resolved_dependencies_with_metadata: Vec<PackageVersionWithRegistryMetadata> =
            resolved_dependencies
                .packages
                .iter()
                .map(|package_version| registry.get_package_version_metadata(package_version))
                .collect::<Result<Vec<_>, _>>()?;

        if !resolved_dependencies_with_metadata.is_empty() {
            // Do not write a lock file if there are no dependencies.
            let path = Self::write(selected_file, &resolved_dependencies_with_metadata)?;
            return Ok(Self {
                _path: Some(path),
                locked_dependencies: resolved_dependencies,
            });
        }

        if let Some(existing_lock_file_path) = previously_locked_path {
            if resolved_dependencies_with_metadata.is_empty() {
                // If there are no dependencies, but there is an existing lock file, remove it.
                std::fs::remove_file(existing_lock_file_path)?;
            }
        }

        // Always re-writing the lock file even if it is the same,
        // I think it is harmless since we're not interested on the creation time.
        Ok(Self {
            _path: None,
            locked_dependencies: resolved_dependencies,
        })
    }
}

#[derive(Serialize, Deserialize)]
pub enum FileVersion {
    #[serde(rename(serialize = "1", deserialize = "1"))]
    V1,
}
/// Set of packages in the form to be serialized to or to be deserialized to or from the lock file.
#[derive(Serialize, Deserialize)]
#[serde(rename(serialize = "package", deserialize = "package"))]
pub struct PackagesInLockFile {
    version: FileVersion,
    #[serde(rename(serialize = "package", deserialize = "package"))]
    packages: Vec<PackageInLockFile>,
}

impl PackagesInLockFile {
    pub fn packages(&self) -> &[PackageInLockFile] {
        &self.packages
    }
}

/// A package in the form to be serialized to or to be deserialized to or from the lock file.
#[derive(Serialize, Deserialize)]
pub struct PackageInLockFile {
    pub name: String,
    pub version: String,
    source: Option<String>,
    ontology_iri: Option<String>,
    checksum: Option<String>,
    pub dependencies: Vec<String>,
}

// Only one way conversion is allowed, for convenience.
#[allow(clippy::from_over_into)]
impl Into<PackageVersion> for &PackageInLockFile {
    fn into(self) -> PackageVersion {
        PackageVersion {
            package_name: self.name.clone(),
            version: self.version.clone(),
        }
    }
}

impl From<PackageVersionWithRegistryMetadata> for PackageInLockFile {
    fn from(package: PackageVersionWithRegistryMetadata) -> Self {
        Self {
            name: package.package_name,
            version: package.version.to_string(),
            // TODO: For example, source = "registry+https://github.com/rust-lang/crates.io-index" ??
            source: None,
            ontology_iri: package.ontology_iri,
            checksum: package.cksum,
            dependencies: package
                .dependencies
                .iter()
                .map(std::string::ToString::to_string)
                .collect_vec(),
        }
    }
}
